# Введение в GIT

*Русский перевод книги [Pro Git](https://git-scm.com/book/ru/v2). Самый полезный и лучший источник информации.*

`git` -- система контроля изменений (версий). Позволяет отслеживать изменения исходного кода приложения, вносимые в разное время разными пользователями в разные файлы, производить восстановление до более ранней версии, делать слияние изменений в коде при параллельной разработке и т.д.

## Установка

_!
Рассматривается только версия для Windows.
!_

Для Windows существует следующий [дистрибутив](https://git-scm.com/download/win). Он содержит утилиту командной строки (`Git Bash`) и простенький графический интерфейс (`Git GUI`). Ни один из известных графических интерфейсов (в т.ч. `Git GUI`) не предоставляет полной свободы действий, потому от его использования стоит отказаться. При установке, однако, следует выбрать пункт меню, добавляющий в контекстное меню проводника команды git (`Git Bash Here`, `Git Init Here` и т.д.).

Система git очень дружелюбна к пользователю. В случае возникновения ошибок, в случае опечаток и т.д. она предложит варианты устранения проблемы. Обычно достаточно проследовать этим инструкциям для разрешения проблемы.

В частности, при попытке выполнения первого коммита система предложит настроить учетную запись, состоящее из логина и почтового адреса:

```sh
$ git config --global user.name "John Doe"
$ git config --global user.email johndoe@example.com
```

## Основы работы

Современные IDE, такие как Visual Studio, NetBeans, Eclipse, уже имеют поддержку git на примитивном уровне. Для повседневной качественной работы, однако, часто требуется (в некоторых случаях необходимо) использовать средства `Git Bash`.

Рассмотрим по порядку базовые команды git. Будем полагать, что работа ведется в `Git Bash`.

### Клонирование репозитория

Репозиторий -- единица персистентности системы Git. В репозитории обычно находится один проект или несколько связанных проектов.

В сети существует много провайдеров, предоставляющих возможности создания (удаленных) git-репозиториев. В частности, это [GitHub](https://github.com/). В качестве примера будем рассматривать именно github.

Для того, чтобы была возможность работать с репозиторием (и, соответственно, его содержимым) на локальном компьютере, необходимо получить локальную копию репозитория. Этим занимается команда `clone`.

```sh
git clone "https://github.com/kalaider/act-photo-random/"
```

Результат команды -- папка `act-photo-random` (и ее содержимое) в текущей рабочей директории.

При необходимости поместить содержимое репозитория в другую директорию, она указывается следующим параметром:

```sh
git clone "https://github.com/kalaider/act-photo-random/" "whatever/you/type"
```

Результат выполнения команды -- папка, путь до которой -- `whatever/you/type`.

Во всех дальнейших примерах будем исходить из того, что текущий рабочий каталог -- как раз папка с репозиторием (`act-photo-random`).

### Выкачивание изменений из удаленного репозитория

```sh
git pull
```

Данная команда автоматически выкачивает изменения из удаленного репозитория и сливает их с локальными. При наличии конфликтов принимаются меры по их устранению.

### Создание локальных изменений

После изменения файла необходимо зафиксировать сделанные в нем изменения. Производится это в два этапа.

На первом файлы добавляются в индекс командой

```sh
git add "my/file1.cpp"
git add "my/file2.cpp"
```

Также в индекс могут быть добавлены сразу все измененные файлы или файлы, удовлетворяющие указанной маске:

```sh
git add '*.cpp'
```

Проверить репозиторий на локальные изменения можно командой `git status`. Она выведет на экран все файлы, содержащие какие-либо изменения относительно текущего коммита.

На втором все добавленные изменения фиксируются. Производится создание нового коммита.

```sh
git commit -m "Commit message - a text describing the new commit"
```

После выполнения команды будет создан новый коммит, а в истории изменений репозитория появится новая запись. Просмотреть историю коммитов можно следующим образом:

```sh
git log
```

Пример вывода команды:

```git
commit 12e46ef16e9fd7500d28ce1580ea5578779d75a7
Author: kalaider <a.kalaider@yandex.ru>
Date:   Wed Mar 8 17:37:09 2017 +0300

    Readme added

commit 20b976e66a2e2e724760c68a94338e31b6939d24
Author: kalaider <a.kalaider@yandex.ru>
Date:   Wed Mar 8 16:32:51 2017 +0300

    ATmega8A component added

commit f284766b0eda5473238139809f2dda8f030cec8a
Author: kalaider <a.kalaider@yandex.ru>
Date:   Wed Mar 8 15:38:08 2017 +0300

    Initial
```

Коммиты идентифицируются своими хэшами (большими шестнадцатеричными числами).

### Внесение изменений в удаленном репозитории

Локальные изменения заливаются в удаленный репозиторий командой

```sh
git push
```

Все конфликты при этом разрешаются руками.

### Откат к предшествующим состояниям

Для отката изменений (добавленных или не добавленных в индекс, перемотка к более ранним коммитам) осуществляется командой

```sh
git reset <начало хэша коммита, имя тега, название ветки т.д.>
```

После этого все локальные изменения (по сравнению с целевым состоянием отката) будут помечены как не проиндексированные. Для физического отката всех таких не проиндексированных изменений к команде добавляется опция `--hard`:

```sh
git reset --hard <начало хэша коммита, имя тега, название ветки т.д.>
```

Теперь репозиторий находится ровно в том состоянии, в котором он был на момент цели отката.

Пример отката к коммиту `Initial`:

```sh
git reset --hard f28476
```

### Работа с ветками

Ветка (branch) -- альтернатива развития проекта. Она может быть создана для исправления ошибки в определенной версии продукта, для внесения экспериментальных изменений в код без "порчи" основной ветки разработки и т.д.

Создание ветки:

```sh
git checkout -b my-new-branch
```

Команда создает ветвь (на это указывает опция `-b`) и устанавливает текущую ветвь (`checkout`) в `my-new-branch`.

Для переключения между ветками используется команда `checkout`:

```sh
git checkout master
```

`master` -- главная ветка разработки любого git-репозитория.

### Слияние веток

После успешного завершения разработки фичи (устранения бага) изменения должны быть слиты с основной веткой разработки (или просто другой веткой). Существует несколько типов слияния. Рассмотрим только `merge`.

Команда `merge` создает новый коммит, который получается слиянием текущего состояния текущей ветки с состоянием сливаемой ветки.

```sh
git checkout master
git merge my-new-branch
```

Данная команда переключается на ветку `master` и сливает в нее ветку `my-new-branch`. После успешного слияния сливаемая ветка может быть удалена:

```sh
git branch -d my-new-branch
```

При конфликте изменений они разводятся руками.

### Еще раз о `git push` и `git pull`

Команда `push` сливает текущую ветку с удаленной веткой (указанной или установленной по умолчанию). Так что результат команды `push` зависит от текущей ветки. Мало чем отличается и поведение `pull`.

# Правила хорошего тона при работе с репозиториями

1. Не использовать ветку `master` в качестве единственной ветки разработки. Ветка `master` -- почти что ранний релиз продукта. В ней должен располагаться максимально стабильный код.
3. Использовать *Pull-реквесты* при необходимости внесения изменений в ветку `master` из другой ветки. После одобрения pull-request'а изменения сливаются администратором проекта в общую ветку.
4. Не коммитить в чужие ветки без разрешения автора ветки.
5. Не плодить тонны веток в удаленном репозитории (в локальном, разумеется, никто не запрещает).
6. Удалять ветки **только** когда они действительно больше не нужны, т.е. слиты в `master` или другую ветку.
7. **Оставлять внятные сообщения коммитов** (желательно на едином для проекта и участников проекта (предпочтительно английском) языке *для однородности и понимания друг друга*; *более того, это устраняет необходимость постоянно переключать раскладку клавиатуры для ввода команд и ввода текста*)